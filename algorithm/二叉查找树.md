##二叉查找树-二叉搜索树-二叉排序树

##二叉查找树递归定义表示
- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	例如:如果y是x左子树中的一个结点，则key[y]<=key[x](关键字的存储方式)。
- 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
	例如:如果y是x右子树中的一个结点，则key[x]<=key[y](关键字的存储方式)。
- 左、右子树也分别为二叉查找树；

##二叉查找树效率
二叉查找树上基本操作的执行时间和树的高度成正比，当树的高度较低时执行速度较快，当树的高度增加甚至变得极度不平衡时，各种操作的性能急剧下降。

##二叉查找树节点数据结构
二叉查找树使用二叉树实现，其节点包括关键字及三个指针域(分别指向左节点、右节点和父节点).为了使用时方便，还提供了带默认参数的构造函数。

##查询
- 比如在如下的二叉查找树中，为了在树中查找关键字13，要沿着从根开始的路径15->6->7->13进行查找。

          15
       /      \
     6         18  
   /   \      /  \
  3     7    17   20 
 / \     \
2   4    13
         /
        9

##前驱和后继

- 查找某个结点的后继
Node* searchSuccessor(Node *x)
{
	//空树
	if (x == NULL) return NULL;

	//有右子树，右子树中最小的那个
	if (x->right != NULL) return searchMin(x->right);

	//无右子树，则为最低的祖先，其左儿子也是祖先
	Node *y = x->parent; //x向上搜索，y为x的父亲
	while (y != NULL &&  x == y->right)
		x = y, y = y->parent;
	return y;
}

- 查找某个结点的前驱
Node *searchPredecessor(Node *x)
{
	//空树
	if (x == NULL) return NULL;

	//有左子树、左子树中最大的那个
	if (x->left != NULL) return searchMax(x->left);

	//无左子树，则为最低的祖先，其右儿子也是祖先
	Node *y = x->parent; //x向上搜索，y为x的父亲
	while (y != NULL && x == y->left)
		x = y, y = y->parent;
	return y;
}

##插入
在左边二叉查找树中插入13时，先沿着12->18->15找到插入的位置，再把13插入到15的左边。

      12                  12			
    /    \             /    \			
  5        18         5        18		
 / \      / \        / \      / \		
2   9   15   19     2   9   15   19		
          \                /  \			
          17              13  17

- 往二叉查找树中插入结点  
  
void insertNode(Node **root, int key)
{
	//根据插入的值创建新节点
	Node *z = new Node(key, NULL, NULL, NULL); 

	//向下搜素插入的位置，x为当前节点，y为其父亲
	Node *x = *root, *y = NULL; 
	while (x != NULL)
	{
		y = x;
		if (key == x->key) return;        //已经存在
		else if(key < x->key) x = x->left;//往左儿子走
		else x = x->right;                //往右儿子走
	}

	//把z插入到y的下方，修正z和y之间的链接
	z->parent = y;
	if (y == NULL) *root = z;
	else if (key < y->key) y->left = z;
	else y->right = z;
}

##删除

- 在下面的二叉查找树中，13没有儿子，直接删除。

      15                      15			
     /  \                     /  \
   5      16                5      16		
  /  \      \             /  \      \
3     12     20         3     12     20		
     /  \   /  \             /      /  \	
    10  13 18  23          10     18  23	
   /                       /				
  6                       6					
   \                       \				
    7                       7		

- 在下面的二叉查找树中，16只有一个儿子，直接删除，然后修正16的父亲15和儿子20的链接关系。

      15                      15
     /  \                   /     \
   5      16               5        20
  /  \      \            /  \     /  \
3     12     20        3     12  18  23   
     /  \   /  \             /  \
    10  13 18  23           10  13 
   /                       /
  6                        6
   \                        \
    7                        7

- 在下面的二叉查找树中，5有两个儿子，知道5的后继6，修正6的父亲10和儿子7的链接关系，并把6复制5的位置，然后删除节点6。

      15                      15
     /  \                    /  \
   5      16               6      16
  /  \      \            /  \      \
3     12     20        3     12     20
     /  \   /  \            /  \   /  \
    10  13 18  23          10  13 18  23
   /                      /
  6                      7
   \
    7